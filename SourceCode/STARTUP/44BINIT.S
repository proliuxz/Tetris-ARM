    GET memcfg.s

;Memory Area
;GCS6 16M 16bit(2MB) DRAM/SDRAM(0xc000000-0xc7fffff)
;APP    RAM=0xc000000~0xc1effff 
;44BMON RAM=0xc7f0000-0xc7fffff
;STACK	   =0xc7ffa00		   

;Interrupt Control
INTPND	    EQU	0x01e00004
INTMOD	    EQU	0x01e00008
INTMSK	    EQU	0x01e0000c
I_ISPR	    EQU	0x01e00020
I_CMST	    EQU	0x01e0001c

;Watchdog timer
WTCON	    EQU	0x01d30000

;Clock Controller
PLLCON	    EQU	0x01d80000
CLKCON	    EQU	0x01d80004
LOCKTIME    EQU	0x01d8000c
	
;Memory Controller
REFRESH	    EQU 0x01c80024

;Pre-defined constants
USERMODE    EQU	0x10
FIQMODE	    EQU	0x11
IRQMODE	    EQU	0x12
SVCMODE	    EQU	0x13
ABORTMODE   EQU	0x17
UNDEFMODE   EQU	0x1b
MODEMASK    EQU	0x1f
NOINT	    EQU	0xc0

;check if tasm.exe is used.
    GBLL    THUMBCODE
    [ {CONFIG} = 16	
THUMBCODE SETL	{TRUE}
    CODE32
    |   
THUMBCODE SETL	{FALSE}
    ]

    [ THUMBCODE
    CODE32   ;for start-up code for Thumb mode
    ]

    MACRO
$HandlerLabel HANDLER $HandleLabel

$HandlerLabel
    sub	    sp,sp,#4	    ;decrement sp(to store jump address)
    stmfd   sp!,{r0}	    ;PUSH the work register to stack(lr does't push because it return to original address)
    ldr	    r0,=$HandleLabel;load the address of HandleXXX to r0
    ldr	    r0,[r0]	    ;load the contents(service routine start address) of HandleXXX
    str	    r0,[sp,#4]	    ;store the contents(ISR) of HandleXXX to stack
    ldmfd   sp!,{r0,pc}	    ;POP the work register and pc(jump to ISR)
    MEND

    AREA    Init,CODE,READONLY

    IMPORT __use_no_semihosting_swi

    ENTRY 
    b ResetHandler  ;for debug
    b HandlerUndef  ;handlerUndef
    b HandlerSWI    ;SWI interrupt handler
    b HandlerPabort ;handlerPAbort
    b HandlerDabort ;handlerDAbort
    b .		    ;handlerReserved
;************************************
    b HandlerIRQ
    b HandlerFIQ
	;***IMPORTANT NOTE***
	;If the H/W vectored interrutp mode is enabled, The above two instructions should
	;be changed like below, to work-around with H/W bug of S3C44B0X interrupt controller. 
	; b HandlerIRQ  ->  subs pc,lr,#4
	; b HandlerIRQ  ->  subs pc,lr,#4
;************************************
VECTOR_BRANCH
    ldr pc,=HandlerEINT0    ;mGA    硬件中断向量表H/W interrupt vector table
    ldr pc,=HandlerEINT1    ;	
    ldr pc,=HandlerEINT2    ;
    ldr pc,=HandlerEINT3    ;
    ldr pc,=HandlerEINT4567 ;
    ldr pc,=HandlerTICK	    ;mGA
    b .
    b .
    ldr pc,=HandlerZDMA0    ;mGB
    ldr pc,=HandlerZDMA1    ;
    ldr pc,=HandlerBDMA0    ;
    ldr pc,=HandlerBDMA1    ;
    ldr pc,=HandlerWDT	    ;
    ldr pc,=HandlerUERR01   ;mGB
    b .
    b .
    ldr pc,=HandlerTIMER0   ;mGC
    ldr pc,=HandlerTIMER1   ;
    ldr pc,=HandlerTIMER2   ;
    ldr pc,=HandlerTIMER3   ;
    ldr pc,=HandlerTIMER4   ;
    ldr pc,=HandlerTIMER5   ;mGC
    b .
    b .
    ldr pc,=HandlerURXD0    ;mGD
    ldr pc,=HandlerURXD1    ;
    ldr pc,=HandlerIIC	    ;
    ldr pc,=HandlerSIO	    ;
    ldr pc,=HandlerUTXD0    ;
    ldr pc,=HandlerUTXD1    ;mGD
    b .
    b .
    ldr pc,=HandlerRTC	    ;mGKA
    b .			    ;
    b .			    ;
    b .			    ;
    b .			    ;
    b .			    ;mGKA
    b .
    b .
    ldr pc,=HandlerADC	    ;mGKB
    b .			    ;
    b .			    ;
    b .			    ;
    b .			    ;
    b .			    ;mGKB
    b .
    b .
;0xe0=EnterPWDN
    ldr pc,=EnterPWDN

    LTORG	

HandlerFIQ		HANDLER HandleFIQ
HandlerIRQ		HANDLER HandleIRQ
HandlerUndef	HANDLER HandleUndef
HandlerSWI		HANDLER HandleSWI
HandlerDabort	HANDLER HandleDabort
HandlerPabort	HANDLER HandlePabort

HandlerADC		HANDLER HandleADC
HandlerRTC		HANDLER HandleRTC
HandlerUTXD1	HANDLER HandleUTXD1
HandlerUTXD0	HANDLER HandleUTXD0
HandlerSIO		HANDLER HandleSIO
HandlerIIC		HANDLER HandleIIC
HandlerURXD1	HANDLER HandleURXD1
HandlerURXD0	HANDLER HandleURXD0
HandlerTIMER5	HANDLER HandleTIMER5
HandlerTIMER4	HANDLER HandleTIMER4
HandlerTIMER3	HANDLER HandleTIMER3
HandlerTIMER2	HANDLER HandleTIMER2
HandlerTIMER1	HANDLER HandleTIMER1
HandlerTIMER0	HANDLER HandleTIMER0
HandlerUERR01	HANDLER HandleUERR01
HandlerWDT		HANDLER HandleWDT
HandlerBDMA1	HANDLER HandleBDMA1
HandlerBDMA0	HANDLER HandleBDMA0
HandlerZDMA1	HANDLER HandleZDMA1
HandlerZDMA0	HANDLER HandleZDMA0
HandlerTICK		HANDLER HandleTICK
HandlerEINT4567	HANDLER HandleEINT4567
HandlerEINT3	HANDLER HandleEINT3
HandlerEINT2	HANDLER HandleEINT2
HandlerEINT1	HANDLER HandleEINT1
HandlerEINT0	HANDLER HandleEINT0


;deal with IRQ interrupt
IRQ_Handler
	IMPORT	ISR_IrqHandler
	STMFD	sp!, {r0-r12, lr}
	BL	ISR_IrqHandler
	LDMFD	sp!, {r0-r12, lr}
	SUBS	pc, lr, #4

	EXPORT IRQ_Handler


;One of the following two routines can be used for non-vectored interrupt.

IsrIRQ	;using I_ISPR register.
    sub	    sp,sp,#4       ;reserved for PC
    stmfd   sp!,{r8-r9}   

	;IMPORTANT CAUTION
	;if I_ISPC isn't used properly, I_ISPR can be 0 in this routine.

    ldr	    r9,=I_ISPR
    ldr	    r9,[r9]

	cmp		r9, #0x0	;If the IDLE mode work-around is used,
						;r9 may be 0 sometimes.
	beq		%F2

    mov	    r8,#0x0
0
    movs    r9,r9,lsr #1
    bcs	    %F1
    add	    r8,r8,#4
    b	    %B0

1
    ldr	    r9,=HandleADC
    add	    r9,r9,r8
    ldr	    r9,[r9]
    str	    r9,[sp,#8]
    ldmfd   sp!,{r8-r9,pc}

2
	ldmfd	sp!,{r8-r9}
	add		sp,sp,#4
	subs	pc,lr,#4

;****************************************************
;*	START					                        *
;****************************************************
ResetHandler
    ldr	    r0,=WTCON	    ;watch dog disable 
    ldr	    r1,=0x0 		
    str	    r1,[r0]

    ldr	    r0,=INTMSK
    ldr	    r1,=0x07ffffff  ;all interrupt disable
    str	    r1,[r0]

    ;****************************************************
    ;*	Set clock control registers			*
    ;****************************************************
    ldr	r0,=LOCKTIME
    ldr	r1,=800	    ; count = t_lock * Fin (t_lock=200us, Fin=4MHz) = 800
    str	r1,[r0]

    [ PLLONSTART
	ldr	r0,=PLLCON			;temporary setting of PLL
	ldr	r1,=((0xe8<<12)+(0x4<<4)+0x2)	;Fin=4MHz,Fvco=160Mhz,Fout=40MHz,m/p/s=0x48/0/0x2
	str	r1,[r0]
    ]

    ldr	    r0,=CLKCON		 
    ldr	    r1,=0x7ff8	    ;All unit block CLK enable	
    str	    r1,[r0]

    ;****************************************************
    ;*	Set memory control registers			* 	
    ;****************************************************
    ldr	    r0,=SMRDATA
    ldmia   r0,{r1-r13}
    ldr	    r0,=0x01c80000  ;BWSCON Address
    stmia   r0,{r1-r13}

    ;****************************************************
    ;*	Initialize stacks				* 
    ;****************************************************
    ldr	    sp, =SVCStack	;Why?
    bl	    InitStacks

    ;****************************************************
    ;*	Setup IRQ handler				*
    ;****************************************************
    ldr	    r0,=HandleIRQ		;This routine is needed
    ldr	    r1,=IRQ_Handler	;=IsrIRQ			;if there isn't 'subs pc,lr,#4' at 0x18, 0x1c
    str	    r1,[r0]

	IMPORT __main
    [ :LNOT:THUMBCODE
	BL	__main	    ;Don't use main() because ......
	B	.						
    ]

    [ THUMBCODE		    ;for start-up code for Thumb mode
	orr     lr,pc,#1
	bx      lr
	CODE16
	bl      Main	    ;Don't use main() because ......
	b       .
	CODE32
    ]

;****************************************************
;*	The function for initializing stack	    *
;****************************************************
        IMPORT UserStack
        IMPORT SVCStack
        IMPORT UndefStack
        IMPORT IRQStack
        IMPORT AbortStack
        IMPORT FIQStack

InitStacks
	;Don't use DRAM,such as stmfd,ldmfd......
	;SVCstack is initialized before
	;Under toolkit ver 2.50, 'msr cpsr,r1' can be used instead of 'msr cpsr_cxsf,r1'

    mrs	    r0,cpsr
    bic	    r0,r0,#MODEMASK
    orr	    r1,r0,#UNDEFMODE|NOINT
    msr	    cpsr_cxsf,r1		;UndefMode
    ldr	    sp,=UndefStack
	
    orr	    r1,r0,#ABORTMODE|NOINT
    msr	    cpsr_cxsf,r1 	    	;AbortMode
    ldr	    sp,=AbortStack

    orr	    r1,r0,#IRQMODE|NOINT
    msr	    cpsr_cxsf,r1 	    	;IRQMode
    ldr	    sp,=IRQStack
	
    orr	    r1,r0,#FIQMODE|NOINT
    msr	    cpsr_cxsf,r1 	    	;FIQMode
    ldr	    sp,=FIQStack

    ;bic	    r0,r0,#MODEMASK|NOINT
    orr	    r1,r0,#SVCMODE|NOINT
    msr	    cpsr_cxsf,r1 	    	;SVCMode
    ldr	    sp,=SVCStack

	;USER mode is not initialized.
    mov	    pc,lr ;The LR register may be not valid for the mode changes.

;****************************************************
;*	The function for entering power down mode   *
;****************************************************
;void EnterPWDN(int CLKCON);
EnterPWDN
    mov	    r2,r0               ;r0=CLKCON
    ldr	    r0,=REFRESH		
    ldr	    r3,[r0]
    mov	    r1, r3
    orr	    r1, r1, #0x400000   ;self-refresh enable
    str	    r1, [r0]

    nop     ;Wait until self-refresh is issued. May not be needed.
    nop     ;If the other bus master holds the bus, ...
    nop	    ; mov r0, r0
    nop
    nop
    nop
    nop

;enter POWERDN mode
    ldr	    r0,=CLKCON
    str	    r2,[r0]

;wait until enter SL_IDLE,STOP mode and until wake-up
    mov	    r0,#0xff
0   subs    r0,r0,#1
    bne	    %B0

;exit from DRAM/SDRAM self refresh mode.
    ldr	    r0,=REFRESH
    str	    r3,[r0]
    mov	    pc,lr

    LTORG
SMRDATA DATA
	DCD BWSCON_cfg
	DCD ((B0_Tacs<<13)+(B0_Tcos<<11)+(B0_Tacc<<8)+(B0_Tcoh<<6)+(B0_Tah<<4)+(B0_Tacp<<2)+(B0_PMC))	;GCS0
	DCD ((B1_Tacs<<13)+(B1_Tcos<<11)+(B1_Tacc<<8)+(B1_Tcoh<<6)+(B1_Tah<<4)+(B1_Tacp<<2)+(B1_PMC))	;GCS1 
	DCD ((B2_Tacs<<13)+(B2_Tcos<<11)+(B2_Tacc<<8)+(B2_Tcoh<<6)+(B2_Tah<<4)+(B2_Tacp<<2)+(B2_PMC))	;GCS2
	DCD ((B3_Tacs<<13)+(B3_Tcos<<11)+(B3_Tacc<<8)+(B3_Tcoh<<6)+(B3_Tah<<4)+(B3_Tacp<<2)+(B3_PMC))	;GCS3
	DCD ((B4_Tacs<<13)+(B4_Tcos<<11)+(B4_Tacc<<8)+(B4_Tcoh<<6)+(B4_Tah<<4)+(B4_Tacp<<2)+(B4_PMC))	;GCS4
	DCD ((B5_Tacs<<13)+(B5_Tcos<<11)+(B5_Tacc<<8)+(B5_Tcoh<<6)+(B5_Tah<<4)+(B5_Tacp<<2)+(B5_PMC))	;GCS5
	[ BDRAMTYPE="DRAM" 
	    DCD ((B6_MT<<15)+(B6_Trcd<<4)+(B6_Tcas<<3)+(B6_Tcp<<2)+(B6_CAN))	;GCS6 check the MT value in parameter.a
	    DCD ((B7_MT<<15)+(B7_Trcd<<4)+(B7_Tcas<<3)+(B7_Tcp<<2)+(B7_CAN))	;GCS7
	| ;"SDRAM"
		DCD ((B6_MT<<15)+(B6_Trcd<<2)+(B6_SCAN))	;GCS6
		DCD ((B7_MT<<15)+(B7_Trcd<<2)+(B7_SCAN))	;GCS7
	]
	DCD ((REFEN<<23)+(TREFMD<<22)+(Trp<<20)+(Trc<<18)+(Tchr<<16)+REFCNT)	;REFRESH RFEN=1, TREFMD=0, trp=3clk, trc=5clk, tchr=3clk,count=1019
	DCD 0x10			;SCLK power down mode, BANKSIZE 32M/32M
	DCD 0x20			;MRSR6 CL=2clk
	DCD 0x20			;MRSR7
	ALIGN

        IMPORT	HandleReset
        IMPORT	HandleUndef
        IMPORT	HandleSWI
        IMPORT	HandlePabort
        IMPORT	HandleDabort
        IMPORT	HandleReserved
        IMPORT	HandleIRQ
        IMPORT	HandleFIQ

        IMPORT	HandleADC
        IMPORT	HandleRTC
        IMPORT	HandleUTXD1
        IMPORT	HandleUTXD0
        IMPORT	HandleSIO
        IMPORT	HandleIIC
        IMPORT	HandleURXD1
        IMPORT	HandleURXD0
        IMPORT	HandleTIMER5
        IMPORT	HandleTIMER4
        IMPORT	HandleTIMER3
        IMPORT	HandleTIMER2
        IMPORT	HandleTIMER1
        IMPORT	HandleTIMER0
        IMPORT	HandleUERR01
        IMPORT	HandleWDT
        IMPORT	HandleBDMA1
        IMPORT	HandleBDMA0
        IMPORT	HandleZDMA1
        IMPORT	HandleZDMA0
        IMPORT	HandleTICK
        IMPORT	HandleEINT4567
        IMPORT	HandleEINT3
        IMPORT	HandleEINT2
        IMPORT	HandleEINT1
        IMPORT	HandleEINT0

		END
